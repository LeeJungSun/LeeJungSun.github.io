# 1. Function 오브젝트 구조, 구성



## 함수형태

- 빌트인 function 오브젝트
  - 내장함수
  - Array.isArray()
  - Array.prototype.forEach()
- function 오브젝트
  - var book = function () {}
  - function book () {}
- function 인스턴스
  - new Book(), new 사용
  - book.prototype의 프로퍼티 사용



## Function 오브젝트

- 함수가 오브젝트여야 호출 가능

- function 오브젝트로 생성 필요

- 엔진이 function 키워드를 만나면 function 오브젝트의 prototype에 연결된 프로퍼티로

  function 오브젝트 생성 / 인스턴스 개념



## 객체 지향 언어

- Function 오브젝트를 객체로 인식, 접근 필요
- 다른 객체에 접근하려면 메소드를 이용하여 호출



## 오브젝트 저장

- function 키워드로 생성한 function 오브젝트를 **{name:value} 형태로 저장**
  - {sports : Function 오브젝트} 형태
- 함수를 호출하면 함수 이름으로 저장된 오브젝트를 검색 value 값을 구하고 value가 Function 오브젝트이면 호출
  - value값에 따라 처리 (함수면 함수로 처리하고~ 배열이면 배열로 처리하고~)



## 아키텍처, 메커니즘

아키텍처 Architecture

- 목적을 가진 구조
- 자바스크립트 목적을 달성하기 위한 구조

메커니즘 Mechanism

- 목적을 달성하기 위한 방법
- 목적에 따라 방법, 기준이 달라질 수 있음

아키텍처와 메커니즘 이해 필요

- 목적와 방법을 모르고 개발하는 모습



## Function 오브젝트 생성 순서, 방법

Function 오브젝트 생성

Function 오브젝트로 저장

- {sports : {....}}
- 오브젝트에 프로퍼티가 없는 상태



## 실행 환경 인식

- Function 오브젝트를 생성하는 시점에 환경 설정(함수에 작성한 코드, 파라미터 실행 영역 등)
- Funcition 오브젝트를 생성하고 바로 실행하는 것이 아니므로 함수가 호출되었을 때 사용할 수 있도록 환경 저장 필요
- 생성한 Function 오브젝트에 저장
- 인식한 환경을 Function 오브젝트의 내부 프로퍼티에 설정



## 내부 프로퍼티

- 엔진이 내부 처리에 사용하는 프로퍼티
- 스펙상의 사양으로 외부(프로그램)에서 사용 불가
- [[]] 형태 예: [[Scope]]



## 내부 프로퍼티 분류

- 공통 프로퍼티
  - 모든 오브젝트에 공통으로 설정됨
- 선택적 프로퍼티
  - 오브젝트에 따라 선택적으로 설정됨
  - 해당되는 오브젝트에 설정



## 함수 정의

함수 정의 형태

- 함수 선언문
- 함수 표현식
- new Function(param1, param2, body) - eval 축소판
  - 문자열로 작성



## 함수 선언문

- function 키워드와 함수 이름 작성

```
function myHome(book, video, audio) {
	return book + video + audio;
};
```



## 함수 표현식

- Function 오브젝트를 생성하여 변수에 할당
- 식별자는 선택으로 함수 이름 작성 (작성해도 변수 이름이 함수 이름이 됨)

```
var name = function () {}
```



## 엔진 해석

함수 선언문 -> 함수 표현식 -> 코드 실행순

- 함수 형태에 따라 해석 순서가 다름
  - 중간에 있는 코드가 먼저 해석될 수 있음
- 먼저 전체 함수 선언문을 차례대로 해석
  - function sports () {};
- 이어서 차례대로 함수 표현식 해석
  - var sports = function () {};



## 코드 해석 단계

- 함수 선언문 해석
  - function sports () {};
- 변수 초기화
  - var sports;
- 코드 실행
  - var sports = function () {};
  - var member = 123;



## 함수 앞에서 호출

- 함수 선언문은 초기화 단계에서 Function 오브젝트를 생성하므로 함수를 호출하는 위치에 영향을 받지 않음

**호이스팅!**



## 함수 선언문 오버라이딩

- 함수 이름이 같을 때 함수 코드 대체 (replace)
- 자바스크립트는 파라미터 수, 데이터 타입을 체크하지 않음 {name : value}로 저장하기 때문
- 초기화 단계에서 위에서부터 함수 선언문을 Function 오브젝트로 생성
- 아래에 같은 이름의 함수 선언문이 있으면 아래의 함수 선언문이 호출 됨





# 2. Argument 오브젝트



## 파라미터 값 매핑

- 파라미터 수가 다를 때도 호출 가능
- 호출 받는 파라미터 기준으로 값 매핑
- 호출 받는 파라미터 이름 수가 적으면 왼쪽에서 오른쪽으로 값 설정
- 호출 받는 파라미터 이름 수가 많으면 매핑하지 못한 파라미터에  undefined 설정



## length 프로퍼티

- 콤마를 기준으로 프로퍼티 수 구분
- arguments.length



## arguments 값 반환

- 파라미터 순서를 0부터 인덱스를 부여하여 key로 사용하고 파라미터로 받은 값을 value에 설정
  - {0 : value, 1 : value}
- 파라미터가 배열일 때 for~in 문으로 읽으면 length프로퍼티를 제외시키는 코드가 필요하기 때문에 **for()문** 사용
- Array-like
  - key값이 0부터 1씩 증가
  - length 프로퍼티가 있어야 함.







# 3. scope

- 함수가 실행될 때 영향을 받는 범위
- 범위가 기준이 아닌 함수가 기준



## scope 사용목적

- 범위 제한
- 신속한 검색 및 접근 스코프 안에서 우선 검색
- 같은 프로퍼티 이름 사용 가능
- 오브젝트로 보면 오브젝트가 다르지만 함수에서 보면 스코프가 다름
  - 실행될 때 함수의 스코프에서 검색
  - 함수 안에서 밖으로 나가는 개념



## scope 구조

- 계층적 구조
- 스코프 안에 스코프가 있는 형태
- 스코프 설정 시점
  - Function 오브젝트를 생성할 때
  - 함수를 호출할 떄 설정하지 않음
  - function 안의 코드에 대해서는 구조를 만들지 않음
- 스코프 구조 형성 방법
  - 밖에서 안으로 들어가면서 스코프 구조 형성
  - 안에서 밖으로 나가면서 스코프 범위 검색



## 글로벌 오브젝트

- 전체 프로그램을 통해 하나만 존재
  - 전체 프로그램 : 모든 <script>에 작성한 코드
- 오브젝트 이름을 작성하지 않고 함수를 호출하면 글로벌 오브젝트로 간주
- new 사용 불가, 인스턴스 생성 불가





## 글로벌 scope

- 전체를 통해 하나만 존재하므로 스코프도 하나
- 글로벌 오브젝트와 글로벌 스코프가 같음
- 스코프가 전체이므로 모든 코드에서 사용 가능
- 최상위 스코프
  - 함수에서 보면 최종 검색 스코프
  - 검색한 프로퍼티가 없으면 undefined 반환
- 스코프 설정
  - 생성한 Function 오브젝트의 [[Scope]]에 설정





## 글로벌 함수

- 글로벌 함수 : 전역 함수
- 로컬 함수 : 지역 함수





## 글로벌 변수

- 글로벌 변수 : 전역 변수
- 로컬 변수 : 지역 변수
  - 함수 안에서 var 키워드를 사용한 변수
  - 함수 안에서 var 키워드를 사용하지 않으면 글로벌 변수
- 글로벌에서 var 키워드를 사용하지 않으면 delete가 실행 됨





## 지역 함수

- 함수 안에서 검색
- 검색 처리의 최적화
- 글로벌 함수 : 어느 위치에서도 함수 호출 가능
- 지역 함수 : 함수 안으로 들어가야 함수 호출 가능





## 지역 변수

- 함수 안에서 검색
- 검색 처리의 최적화
- 글로벌 변수 : 어느 위치에서도 변수 사용 가능
- 지역 변수 : 함수 안으로 들어가야 변수 접근 가능 / 함수 외부에서 직접 사용 불가





## 바인딩

- 구조적으로 결속된 상태로 만드는 것
- 대상 : 오브젝트와 프로퍼티 이름
- 바인딩 목적
  - 스코프 결정
  - 스코프에서 이름 식별 -> 식별자 해결이라고 함
- 바인딩 시점 분류
  - 정적 바인딩
  - 동적 바인딩





## 스코프 체인

- 스코프가 상하 구조로 연결된 개념/구조
- 스코프 체인을 사용하여 근접한 스코프에서 프로퍼티(함수, 변수)검색
- ES5에서 스코프 체인 개념 폐지 -> 렉시컬 환결 개념 사용





## 바인딩 시점

정적 바인딩

- 초기화 단계에서 바인딩
- 함수 선언문 이름으로 반인딩
- 변수, 함수 표현식 이름으로 바인딩
- 대부분 정적 바인딩
- 값은 바인딩 대상이 아님

동적 바인딩

- 실행 단계에서 바인딩
- eval() 함수, with 문





## 바인딩 시점의 중요성

- 바인딩할 떄 스코프가 결정되기 때문
- Function 오브젝트 생성 시점에 스코프 결정
  - 인식한 스코프를 [[Scope]]에 설정
  - 정적 바인딩은 [[Scope]]를 스코프로 사용
  - 스코프가 변경되지 않음
- 같은 단계의 모든 함수의 스코프가 같음





## 프로퍼티 검색 방법

- [[Scope]] 프로퍼티에서 검색
- function 오브젝트를 생성할 때 바인딩하였기 때문에 프로퍼티 검색을 위한 추가 처리 불필요
- 처리 속도에 영향을 미치지 않음